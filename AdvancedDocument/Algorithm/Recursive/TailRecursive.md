尾递归和循环效率是一样的,编译器会优化

以前只是听说过但是没有具体去理解

尾递归每次调用递归都会计算一个相应的结果。


想办法每一次调用的时候计算一个值，这是将普通递归转换为尾递归的关键，也是识别是不是尾递归的方法吧！

## Factorial

这种递归需要O(n^2)栈空间,递归栈太深了就会有很大的效率问题。

## Fibonacci

```cs
public long Recursive(long n)
{
    if (n == 1 || n == 2)
    {
        return 1;
    }
    return Recursive(n-1) + Recursive(n - 2);
}
```

这种递归需要O(2^n)栈空间,而尾递归只是O(n),循环是O(1)。

今天才知道之前的面试的时候人家对我写的Fibonacci递归计算为什么不满。


        
        