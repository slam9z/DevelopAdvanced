其中根节点可能有多个，所以也可能是深林。

更通用的是一个数据只包含自己的Id和ParentId，如果ParentId is empty则是根节点。

## 创建树的方法

1. 之前都是使用简单的算法，先选根节点，再选择子节点，感觉效率有点低，这种算法是$O（n^2）$

    分析后发现这种效率还不错。

1. 可以扫到一个节点就添加到树中，总是保持性质对就行。

## 算法分析

### 实例

假设树为一个二叉树。

1                   L1

2      3            L2

4   5  6  7         L3
...                 Lm

Lm表示节点在高度。

$$
n=(N(L1)+N(L2)+...(Lm))
$$


### 方法1 找根
 
大致计算每一层花的时间

L1  $n$
L2  $2^0(n-1)$
L3  $2^1(n-1-2)$
Lm  $2^(m-1)(n-1-2-2^(m-1))

每一层都是O(n),所以总共是O是$nlgn$。

和创建二叉查找树一样。

### 方法2 插入

假设数据为节点都在根节点前。

每一次插入只与已经插入的数比较，不是简单的比较就行了，这个简单的不可行。


虚拟占位？不管有没有加载父节点先创建一个。然后假设虚拟的父节点都是根节点。

第一个插入，创建一个包含根节点的树，然后以后的就直接从根节点插入。

使用广度搜索。

$$
(1+2+3+...+n)=n(n+1)/2
$$

又复杂效率还是比较低。


