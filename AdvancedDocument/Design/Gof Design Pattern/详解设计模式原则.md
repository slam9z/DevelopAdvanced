原则:

* 单一职责原则
* 开闭原则（Open Closed Principle，OCP）
* 里氏替换原则（Liskov Substitution Principle,LSP）
* 依赖倒转原则（Dependency Inversion Principle,DIP）
* 接口隔离原则（Interface Segregation Principle,ISP）
* 合成/聚合复用原则（ Composite/Aggregate Reuse Principle,CARP）
* 最小化知识原则（Principle of  Least Knowledge,PLK,也叫迪米特法则-Law of Demeter，LoD ）

开闭原则具有理想主义的色彩，它是面向对象设计的终极目标。其他几条，则可以看做是开闭原则的实现方法。 设计模式就是实现了这些原则，从而达到了代码复用、增加可维护性的目的。

*设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的；设计模式使代码编制真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。
借用并改编一下鲁迅老师《故乡》中的一句话，一句话概括设计模式: 希望本无所谓有，无所谓无．这正如coding的设计模式，其实coding本没有设计模式，用的人多了，也便成了设计模式*


## 单一职责原则

　　就一个类而言，应该只有一个引起它变化的原因。如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会影响到其他的职责，另外，把多个职责耦合在一起，也会影响复用性

## 开闭原则

1. 概念： 

    一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。模块应尽量在不修改原（是“原”，指原来的代码）代码的情况下进行扩展。

2. 模拟场景： 

    在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。

3. Solution： 

    当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。

4. 注意事项： 

    * 通过接口或者抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法
    * 参数类型、引用对象尽量使用接口或者抽象类，而不是实现类
    * 抽象层尽量保持稳定，一旦确定即不允许修改

5. 开闭原则的优点： 

    * 可复用性
    * 可维护性


## 里氏代换原则

1. 概述： 派生类(子类)对象能够替换其基类(父类)对象被调用

2. 概念： 

    里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。(源自百度百科)

3. 子类为什么可以替换父类的位置？： 

    当满足继承的时候，父类肯定存在非私有成员，子类肯定是得到了父类的这些非私有成员（假设，父类的的成员全部是私有的，那么子类没办法从父类继承任何成员，也就不存在继承的概念了）。既然子类继承了父类的这些非私有成员，那么父类对象也就可以在子类对象中调用这些非私有成员。所以，子类对象可以替换父类对象的位置。

4. 里氏代换原则优点： 

    需求变化时，只须继承，而别的东西不会改变。由于里氏代换原则才使得开放封闭成为可能。这样使得子类在父类无需修改的话就可以扩展。

## 依赖倒转原则    

1. 概念： 

    依赖倒置原则（Dependence Inversion Principle）是程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。

2. 依赖倒转原则用处： 


3. 注意事项： 

    * 高层模块不应该依赖低层模块。两个都应该依赖抽象。
    * 抽象不应该依赖结节。细节应该依赖抽象。

## 接口隔离原则

1. 概念： 

    客户端不应该依赖它不需要的接口，类间的依赖关系应该建立在最小的接口上

2. 含义： 

    接口隔离原则的核心定义，不出现臃肿的接口（Fat Interface），但是“小”是有限度的，首先就是不能违反单一职责原则。



##合成/聚合复用原则

1. 概念： 

    合成/聚合复用原则（Composite/Aggregate Reuse Principle，CARP）经常又叫做合成复用原则。合成/聚合复用原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新的对象通过向这些对象的委派达到复用已有功能的目的。它的设计原则是：要尽量使用合成/聚合，尽量不要使用继承。

2. 合成/聚合解析： 


    * 聚合概念： 

    聚合用来表示“拥有”关系或者整体与部分的关系。代表部分的对象有可能会被多个代表整体的对象所共享，而且不一定会随着某个代表整体的对象被销毁或破坏而被销毁或破坏，部分的生命周期可以超越整体。例如，Iphone5和IOS，当Iphone5删除后，IOS还能存在，IOS可以被Iphone6引用。


    * 合成概念： 

    合成用来表示一种强得多的“拥有”关系。在一个合成关系里，部分和整体的生命周期是一样的。一个合成的新对象完全拥有对其组成部分的支配权，包括它们的创建和湮灭等。使用程序语言的术语来说，合成而成的新对象对组成部分的内存分配、内存释放有绝对的责任。一个合成关系中的成分对象是不能与另一个合成关系共享的。一个成分对象在同一个时间内只能属于一个合成关系。如果一个合成关系湮灭了，那么所有的成分对象要么自己湮灭所有的成分对象（这种情况较为普遍）要么就得将这一责任交给别人（较为罕见）。例如：水和鱼的关系，当水没了，鱼也不可能独立存在。


## 迪米特法则

1. 概念： 

    一个软件实体应当尽可能少的与其他实体发生相互作用。每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。迪米特法则的初衷在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。迪米特法则不希望类之间建立直接的联系。如果真的有需要建立联系，也希望能通过它的友元类来转达。因此，应用迪米特法则有可能造成的一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系——这在一定程度上增加了系统的复杂度。

*想搞懂设计模式，必须先知道设计模式遵循的六大原则，无论是哪种设计模式都会遵循一种或者多种原则。这是面向对象不变的法则。*


[详解设计模式六大原则](http://www.cnblogs.com/toutou/p/4870926.html)

[C#设计模式总结](http://www.cnblogs.com/zhili/p/DesignPatternSummery.html)
